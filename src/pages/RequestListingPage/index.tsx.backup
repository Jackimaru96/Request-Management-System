import { JSX, useState, useMemo } from "react";
import { Box, Chip, Tooltip } from "@mui/material";
import EditIcon from "@mui/icons-material/Edit";
import DeleteIcon from "@mui/icons-material/Delete";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import AddIcon from "@mui/icons-material/Add";
import RemoveIcon from "@mui/icons-material/Remove";
import FiberManualRecordIcon from "@mui/icons-material/FiberManualRecord";
import { NdsDataGrid, GridColDef, type NdsBaseSelectOption } from "@nautilus/nds-react";
import { Task, TaskDisplay, ChangeStatus } from "./types";
import { tasksToDisplay } from "./helpers";
import AddTasksStagingDialog from "./components/AddTasksStagingDialog";
import { useTasksQuery, useCreateTaskMutation } from "../../queries/tasks";

function RequestListingPage(): JSX.Element {
  const [quickFilterSearch, setQuickFilterSearch] = useState("");
  const [taskTypeFilter, setTaskTypeFilter] = useState<NdsBaseSelectOption[]>([]);
  const [priorityFilter, setPriorityFilter] = useState<NdsBaseSelectOption[]>([]);
  const [paginationModel, setPaginationModel] = useState({
    pageSize: 10,
    page: 0,
  });
  const [addTasksDialogOpen, setAddTasksDialogOpen] = useState(false);

  // Fetch tasks using React Query
  const { data: tasks = [], isLoading, isError } = useTasksQuery();
  const createTaskMutation = useCreateTaskMutation();

  // Convert tasks to display format
  const rows: TaskDisplay[] = useMemo(() => tasksToDisplay(tasks), [tasks]);

  // Calculate if there are pending changes
  const hasPendingChanges = useMemo(() => {
    return tasks.some(
      (task) => task.changeStatus === ChangeStatus.ADDED || task.changeStatus === ChangeStatus.DELETED
    );
  }, [tasks]);

  // Count pending changes
  const pendingChangesCount = useMemo(() => {
    return tasks.filter(
      (task) => task.changeStatus === ChangeStatus.ADDED || task.changeStatus === ChangeStatus.DELETED
    ).length;
  }, [tasks]);

  // Handle adding multiple tasks
  const handleAddTasks = (
    newTasks: Omit<
      Task,
      | "id"
      | "createdTime"
      | "user"
      | "userGroup"
      | "version"
      | "changeStatus"
      | "latestEvent"
      | "collectionStatus"
      | "colEndTime"
      | "estimatedColDuration"
    >[]
  ): void => {
    // Use the mutation to create each task
    newTasks.forEach((newTask) => {
      createTaskMutation.mutate(newTask);
    });

    // Close dialog after all tasks are submitted
    setAddTasksDialogOpen(false);
  };

  const columns: GridColDef[] = [
    {
      // From TMS_Request
      id: "1",
      url: "api.example.com/v1/climate-data",
      requestType: RequestType.RECURRING,
      priority: Priority.URGENT,
      contentType: "post",
      createdTime: new Date("2026-01-15T10:00:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 3,
      country: "United States",
      depth: { type: DepthType.LAST_HOURS, hours: 2 },
      // From latest TMSRequestEvent
      latestEvent: {
        _id: "evt-1",
        requestId: "1",
        eventType: EventType.CREATE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-15T10:00:00"),
        version: 1,
      },
      user: "user123",
      // From Col_Request - no collection yet
      collectionStatus: undefined,
      colEndTime: undefined,
      estimatedColDuration: undefined,
      // UI-derived
      changeStatus: deriveChangeStatus({
        _id: "evt-1",
        requestId: "1",
        eventType: EventType.CREATE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-15T10:00:00"),
        version: 1,
      }),
    },
    {
      id: "2",
      url: "metrics-api.cloud/collection",
      requestType: RequestType.RECURRING,
      priority: Priority.HIGH,
      contentType: "post",
      createdTime: new Date("2026-01-15T10:00:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 3,
      country: "Australia",
      depth: { type: DepthType.LAST_HOURS, hours: 2 },
      latestEvent: {
        _id: "evt-2",
        requestId: "2",
        eventType: EventType.UPDATE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "update" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-15T10:00:00"),
        version: 1,
      },
      user: "user123",
      collectionStatus: undefined,
      colEndTime: undefined,
      estimatedColDuration: undefined,
      changeStatus: deriveChangeStatus({
        _id: "evt-2",
        requestId: "2",
        eventType: EventType.UPDATE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "update" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-15T10:00:00"),
        version: 1,
      }),
    },
    {
      id: "3",
      url: "weather-data.science/metrics",
      requestType: RequestType.RECURRING,
      priority: Priority.MEDIUM,
      contentType: "post",
      createdTime: new Date("2026-01-14T08:45:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 2,
      country: "United Kingdom",
      depth: { type: DepthType.LAST_HOURS, hours: 2 },
      latestEvent: {
        _id: "evt-3",
        requestId: "3",
        eventType: EventType.DELETE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "delete" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T08:45:00"),
        version: 1,
      },
      user: "user456",
      collectionStatus: CollectionStatus.COMPLETED,
      colEndTime: new Date("2026-01-14T09:30:00"),
      estimatedColDuration: 45,
      changeStatus: deriveChangeStatus({
        _id: "evt-3",
        requestId: "3",
        eventType: EventType.DELETE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "delete" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T08:45:00"),
        version: 1,
      }),
    },
    {
      id: "4",
      url: "global-climate.net/sensors",
      requestType: RequestType.RECURRING,
      priority: Priority.URGENT,
      contentType: "post",
      createdTime: new Date("2026-01-14T10:45:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 1,
      country: "Singapore",
      depth: { type: DepthType.LAST_HOURS, hours: 2 },
      latestEvent: {
        _id: "evt-4",
        requestId: "4",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user789",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T10:45:00"),
        version: 1,
      },
      user: "user789",
      collectionStatus: CollectionStatus.PENDING_C,
      colEndTime: undefined,
      estimatedColDuration: 30,
      changeStatus: deriveChangeStatus({
        _id: "evt-4",
        requestId: "4",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user789",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T10:45:00"),
        version: 1,
      }),
    },
    {
      id: "5",
      url: "climate-monitor.global/api/temp",
      requestType: RequestType.ADHOC,
      priority: Priority.HIGH,
      contentType: "post",
      createdTime: new Date("2026-01-14T09:15:00"),
      userGroup: "analysts",
      version: 1,
      country: "Germany",
      depth: { type: DepthType.LAST_DAYS, days: 2 },
      latestEvent: {
        _id: "evt-5",
        requestId: "5",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T09:15:00"),
        version: 1,
      },
      user: "user123",
      collectionStatus: CollectionStatus.COLLECTING,
      colEndTime: undefined,
      estimatedColDuration: 120,
      changeStatus: deriveChangeStatus({
        _id: "evt-5",
        requestId: "5",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T09:15:00"),
        version: 1,
      }),
    },
    {
      id: "6",
      url: "environment-tracker.io/data",
      requestType: RequestType.RECURRING,
      priority: Priority.HIGH,
      contentType: "post",
      createdTime: new Date("2026-01-14T07:20:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 4,
      country: "Japan",
      depth: { type: DepthType.LAST_DAYS, days: 3 },
      latestEvent: {
        _id: "evt-6",
        requestId: "6",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T07:20:00"),
        version: 1,
      },
      user: "user456",
      collectionStatus: CollectionStatus.COMPLETED,
      colEndTime: new Date("2026-01-14T10:30:00"),
      estimatedColDuration: 180,
      changeStatus: deriveChangeStatus({
        _id: "evt-6",
        requestId: "6",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T07:20:00"),
        version: 1,
      }),
    },
    {
      id: "7",
      url: "temperature-monitor.io/latest",
      requestType: RequestType.RECURRING,
      priority: Priority.HIGH,
      contentType: "post",
      createdTime: new Date("2026-01-14T10:00:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 2,
      country: "France",
      depth: { type: DepthType.LAST_HOURS, hours: 2 },
      latestEvent: {
        _id: "evt-7",
        requestId: "7",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user789",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T10:00:00"),
        version: 1,
      },
      user: "user789",
      collectionStatus: CollectionStatus.SUSPENDED,
      colEndTime: new Date("2026-01-14T11:15:00"),
      estimatedColDuration: 60,
      changeStatus: deriveChangeStatus({
        _id: "evt-7",
        requestId: "7",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user789",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T10:00:00"),
        version: 1,
      }),
    },
    {
      id: "8",
      url: "eco-sensors.worldwide/api",
      requestType: RequestType.LIVESTREAM,
      priority: Priority.MEDIUM,
      contentType: "post",
      createdTime: new Date("2026-01-14T05:30:00"),
      userGroup: "analysts",
      version: 1,
      cutOffTime: new Date("2026-01-31T23:59:59"),
      country: "Canada",
      depth: {
        type: DepthType.DATE_RANGE,
        startDate: new Date("2026-01-01"),
        endDate: new Date("2026-01-31"),
      },
      latestEvent: {
        _id: "evt-8",
        requestId: "8",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T05:30:00"),
        version: 1,
      },
      user: "user123",
      collectionStatus: CollectionStatus.ERROR,
      colEndTime: new Date("2026-01-14T06:45:00"),
      estimatedColDuration: 240,
      changeStatus: deriveChangeStatus({
        _id: "evt-8",
        requestId: "8",
        eventType: EventType.CREATE,
        status: EventStatus.PENDING_UPLOAD,
        payload: JSON.stringify({ action: "create" }),
        user: "user123",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T05:30:00"),
        version: 1,
      }),
    },
    {
      id: "9",
      url: "data-hub.research.org/endpoints",
      requestType: RequestType.ADHOC,
      priority: Priority.MEDIUM,
      contentType: "post",
      createdTime: new Date("2026-01-14T04:15:00"),
      userGroup: "analysts",
      version: 1,
      country: "India",
      depth: { type: DepthType.LAST_DAYS, days: 2 },
      latestEvent: {
        _id: "evt-9",
        requestId: "9",
        eventType: EventType.CREATE,
        status: EventStatus.UPLOADED,
        payload: JSON.stringify({ action: "create" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T04:15:00"),
        version: 1,
        uploadedTime: new Date("2026-01-14T04:20:00"),
      },
      user: "user456",
      collectionStatus: CollectionStatus.COMPLETED,
      colEndTime: new Date("2026-01-14T06:30:00"),
      estimatedColDuration: 120,
      changeStatus: deriveChangeStatus({
        _id: "evt-9",
        requestId: "9",
        eventType: EventType.CREATE,
        status: EventStatus.UPLOADED,
        payload: JSON.stringify({ action: "create" }),
        user: "user456",
        userGroup: "analysts",
        createdTime: new Date("2026-01-14T04:15:00"),
        version: 1,
        uploadedTime: new Date("2026-01-14T04:20:00"),
      }),
    },
    {
      id: "10",
      url: "atmospheric-data.org/readings",
      requestType: RequestType.RECURRING,
      priority: Priority.LOW,
      contentType: "post",
      createdTime: new Date("2026-01-14T06:00:00"),
      userGroup: "analysts",
      version: 1,
      recurringFreq: 8,
      country: "Brazil",
      depth: { type: DepthType.LAST_DAYS, days: 4 },
      latestEvent: undefined, // No event yet
      user: "user789",
      collectionStatus: CollectionStatus.COMPLETED,
      colEndTime: new Date("2026-01-14T12:00:00"),
      estimatedColDuration: 360,
      changeStatus: deriveChangeStatus(undefined),
    },
  ]);

  // Convert tasks to display format
  const rows: TaskDisplay[] = useMemo(() => tasksToDisplay(tasks), [tasks]);

  // Calculate if there are pending changes
  const hasPendingChanges = useMemo(() => {
    return tasks.some(
      (task) => task.changeStatus === ChangeStatus.ADDED || task.changeStatus === ChangeStatus.DELETED
    );
  }, [tasks]);

  // Count pending changes
  const pendingChangesCount = useMemo(() => {
    return tasks.filter(
      (task) => task.changeStatus === ChangeStatus.ADDED || task.changeStatus === ChangeStatus.DELETED
    ).length;
  }, [tasks]);

  // Handle adding multiple tasks
  const handleAddTasks = (
    newTasks: Omit<
      Task,
      | "id"
      | "createdTime"
      | "user"
      | "userGroup"
      | "version"
      | "changeStatus"
      | "latestEvent"
      | "collectionStatus"
      | "colEndTime"
      | "estimatedColDuration"
    >[]
  ): void => {
    const currentTime = new Date();
    const currentUser = "current_user"; // TODO: Get from auth context
    const currentUserGroup = "default_group"; // TODO: Get from auth context

    const tasksToAdd: Task[] = newTasks.map((newTask, index) => {
      const taskId = `temp-${Date.now()}-${index}`;
      const eventId = `evt-temp-${Date.now()}-${index}`;

      // Create the event for this new task
      const event = {
        _id: eventId,
        requestId: taskId,
        eventType: EventType.CREATE,
        status: EventStatus.LOCAL,
        payload: JSON.stringify({ action: "create", data: newTask }),
        user: currentUser,
        userGroup: currentUserGroup,
        createdTime: currentTime,
        version: 1,
      };

      return {
        ...newTask,
        id: taskId,
        createdTime: currentTime,
        user: currentUser,
        userGroup: currentUserGroup,
        version: 1,
        // From latest TMSRequestEvent
        latestEvent: event,
        // From Col_Request - no collection yet for new tasks
        collectionStatus: undefined,
        colEndTime: undefined,
        estimatedColDuration: undefined,
        // UI-derived from the event
        changeStatus: deriveChangeStatus(event), // Will be ChangeStatus.ADDED
      };
    });

    // Add all new tasks to the beginning of the list
    setTasks([...tasksToAdd, ...tasks]);

    // TODO: Make API call to persist the tasks to the backend
    // POST to /api/requests to create TMS_Request
    // POST to /api/request-events to create TMS_Request_Event
    // After API success, update the tasks with real IDs from the server
  };

  const columns: GridColDef[] = [
    {
      field: "changeStatus",
      headerName: "",
      width: 50,
      sortable: false,
      disableColumnMenu: true,
      renderCell: (params): JSX.Element | null => {
        const changeStatus = params.value as ChangeStatus | null;

        if (changeStatus === ChangeStatus.ADDED) {
          return (
            <Tooltip title="Will be added in next export" placement="right">
              <Box sx={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                <AddIcon sx={{ color: "success.main" }} />
              </Box>
            </Tooltip>
          );
        }

        if (changeStatus === ChangeStatus.DELETED) {
          return (
            <Tooltip title="Will be deleted in next export" placement="right">
              <Box sx={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                <RemoveIcon sx={{ color: "error.main" }} />
              </Box>
            </Tooltip>
          );
        }

        if (changeStatus === ChangeStatus.PENDING_UPLOAD) {
          return (
            <Tooltip title="Pending XML upload to W" placement="right">
              <Box sx={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                <FiberManualRecordIcon sx={{ color: "primary.main", fontSize: "12px" }} />
              </Box>
            </Tooltip>
          );
        }

        return null;
      },
    },
    {
      field: "url",
      headerName: "URL",
      flex: 2.5,
      minWidth: 250,
    },
    {
      field: "taskType",
      headerName: "Task Type",
      flex: 1,
      minWidth: 120,
    },
    {
      field: "frequency",
      headerName: "Frequency",
      flex: 1.2,
      minWidth: 140,
    },
    {
      field: "depth",
      headerName: "Depth",
      flex: 1.5,
      minWidth: 150,
    },
    {
      field: "priority",
      headerName: "Priority",
      flex: 0.8,
      minWidth: 100,
      renderCell: (params): JSX.Element => {
        const priority = params.value as string;
        const priorityColors: Record<string, { bg: string; text: string }> = {
          Urgent: { bg: "#d32f2f", text: "#fff" },
          High: { bg: "#ed6c02", text: "#fff" },
          Medium: { bg: "#0288d1", text: "#fff" },
          Low: { bg: "#2e7d32", text: "#fff" },
        };

        const colors = priorityColors[priority] || { bg: "#757575", text: "#fff" };

        return (
          <Chip label={priority} size="small" sx={{ bgcolor: colors.bg, color: colors.text }} />
        );
      },
    },
    {
      field: "country",
      headerName: "Country",
      flex: 1.2,
      minWidth: 150,
    },
    {
      field: "status",
      headerName: "Status",
      flex: 1,
      minWidth: 120,
    },
    {
      field: "lastCollected",
      headerName: "Last Collected",
      flex: 1.5,
      minWidth: 180,
    },
  ];

  return (
    <Box sx={{ padding: "32px 64px 16px 64px" }}>
      <NdsDataGrid
        disableRowSelectionOnClick
        rows={rows}
        columns={columns}
        tableTitle="TMS"
        primaryButton={{
          label: "Add Tasks",
          onClick: (): void => {
            setAddTasksDialogOpen(true);
          },
        }}
        toolbarButtons={
          hasPendingChanges
            ? [
                {
                  label: `Review Changes (${pendingChangesCount})`,
                  onClick: (): void => {
                    // TODO: Open review changes dialog
                  },
                },
              ]
            : []
        }
        menuItems={[
          {
            label: "Edit",
            icon: <EditIcon color="action" />,
            onClick: (params: TaskDisplay): void => {
              // TODO: Open edit dialog
              console.log("Edit", params);
            },
          },
          {
            label: "Delete",
            icon: <DeleteIcon color="action" />,
            onClick: (params: TaskDisplay): void => {
              // TODO: Open delete confirmation dialog
              console.log("Delete", params);
            },
          },
          {
            label: "Duplicate",
            icon: <ContentCopyIcon color="action" />,
            onClick: (params: TaskDisplay): void => {
              // TODO: Open duplicate dialog
              console.log("Duplicate", params);
            },
          },
        ]}
        rowMenu
        checkboxSelection
        rowCount={rows.length}
        pageSizeOptions={[10, 25, 50]}
        paginationMode="client"
        paginationModel={paginationModel}
        onPaginationModelChange={setPaginationModel}
        filters={[
          {
            type: "QuickFilter",
            props: {
              value: quickFilterSearch,
              onChange: setQuickFilterSearch,
            },
          },
          {
            type: "MultiSelect",
            props: {
              label: "Task Type",
              options: [{ title: "Recurring" }, { title: "Ad-Hoc" }, { title: "Livestream" }],
              value: taskTypeFilter,
              onChange: setTaskTypeFilter,
            },
          },
          {
            type: "MultiSelect",
            props: {
              label: "Priority",
              options: [
                { title: "Urgent" },
                { title: "High" },
                { title: "Medium" },
                { title: "Low" },
              ],
              value: priorityFilter,
              onChange: setPriorityFilter,
            },
          },
        ]}
      />

      {/* Add Tasks Dialog with Staging */}
      <AddTasksStagingDialog
        open={addTasksDialogOpen}
        onClose={() => setAddTasksDialogOpen(false)}
        onAddTasks={handleAddTasks}
      />
    </Box>
  );
}

export default RequestListingPage;
